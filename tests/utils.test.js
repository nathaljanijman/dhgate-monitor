/**\n * Unit Tests for DHgate Monitor Utility Functions\n * \n * These tests verify the core security, caching, and analytics utilities\n * that power the DHgate Monitor application.\n */\n\n// Mock dependencies\nglobal.crypto = {\n  getRandomValues: (array) => {\n    for (let i = 0; i < array.length; i++) {\n      array[i] = Math.floor(Math.random() * 256);\n    }\n    return array;\n  }\n};\n\n// Mock gtag function\nglobal.gtag = jest.fn();\nglobal.sessionStorage = {\n  getItem: jest.fn(),\n  setItem: jest.fn()\n};\n\n// Import the utility classes (would need to be extracted from main file)\n// For this test, we'll define them inline as they would be extracted\n\nclass SecurityUtils {\n  static validateEmail(email) {\n    if (!email || typeof email !== 'string') {\n      return { isValid: false, error: 'Email is required' };\n    }\n    \n    const sanitized = email.trim().toLowerCase();\n    \n    if (sanitized.length > 254) {\n      return { isValid: false, error: 'Email too long' };\n    }\n    \n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(sanitized)) {\n      return { isValid: false, error: 'Invalid email format' };\n    }\n    \n    return { isValid: true, sanitized };\n  }\n  \n  static validateShopUrl(url) {\n    if (!url || typeof url !== 'string') {\n      return { isValid: false, error: 'URL is required' };\n    }\n    \n    const sanitized = url.trim();\n    \n    if (sanitized.length > 2048) {\n      return { isValid: false, error: 'URL too long' };\n    }\n    \n    try {\n      const parsed = new URL(sanitized);\n      const allowedDomains = ['dhgate.com', 'dhgate.co.uk'];\n      const isAllowedDomain = allowedDomains.some(domain => \n        parsed.hostname.includes(domain)\n      );\n      \n      if (!isAllowedDomain) {\n        return { isValid: false, error: 'Only DHgate URLs are allowed' };\n      }\n      \n      return { isValid: true, sanitized };\n    } catch {\n      return { isValid: false, error: 'Invalid URL format' };\n    }\n  }\n  \n  static sanitizeHtml(input) {\n    if (!input || typeof input !== 'string') return '';\n    \n    return input\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#x27;')\n      .replace(/\\//g, '&#x2F;');\n  }\n  \n  static generateCSRFToken() {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n  }\n}\n\nclass ErrorHandler {\n  static async withRetry(fn, maxRetries = 3, baseDelay = 1000) {\n    let lastError;\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error;\n        \n        if (attempt === maxRetries) {\n          throw error;\n        }\n        \n        const delay = baseDelay * Math.pow(2, attempt - 1) + Math.random() * 1000;\n        await this.delay(delay);\n      }\n    }\n  }\n  \n  static delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  static async safeExecute(fn, operation, fallbackValue = null) {\n    try {\n      return await fn();\n    } catch (error) {\n      console.error(`❌ ${operation} failed:`, error.message);\n      return fallbackValue;\n    }\n  }\n}\n\nclass AnalyticsService {\n  static trackConversion(eventName, parameters = {}) {\n    if (typeof gtag !== 'function') return;\n    \n    gtag('event', eventName, {\n      ...parameters,\n      event_category: 'conversion',\n      event_timestamp: new Date().toISOString(),\n      session_id: this.getSessionId()\n    });\n  }\n  \n  static getSessionId() {\n    let sessionId = sessionStorage.getItem('dhgate_session_id');\n    if (!sessionId) {\n      sessionId = 'sess_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n      sessionStorage.setItem('dhgate_session_id', sessionId);\n    }\n    return sessionId;\n  }\n}\n\n// Tests\ndescribe('SecurityUtils', () => {\n  describe('validateEmail', () => {\n    test('should validate correct email addresses', () => {\n      const result = SecurityUtils.validateEmail('test@example.com');\n      expect(result.isValid).toBe(true);\n      expect(result.sanitized).toBe('test@example.com');\n    });\n    \n    test('should reject invalid email addresses', () => {\n      const invalidEmails = [\n        'invalid-email',\n        '@example.com',\n        'test@',\n        '',\n        null,\n        undefined\n      ];\n      \n      invalidEmails.forEach(email => {\n        const result = SecurityUtils.validateEmail(email);\n        expect(result.isValid).toBe(false);\n        expect(result.error).toBeDefined();\n      });\n    });\n    \n    test('should trim and lowercase email addresses', () => {\n      const result = SecurityUtils.validateEmail('  TEST@Example.COM  ');\n      expect(result.isValid).toBe(true);\n      expect(result.sanitized).toBe('test@example.com');\n    });\n    \n    test('should reject overly long email addresses', () => {\n      const longEmail = 'a'.repeat(250) + '@example.com';\n      const result = SecurityUtils.validateEmail(longEmail);\n      expect(result.isValid).toBe(false);\n      expect(result.error).toBe('Email too long');\n    });\n  });\n  \n  describe('validateShopUrl', () => {\n    test('should validate DHgate URLs', () => {\n      const validUrls = [\n        'https://www.dhgate.com/store/12345',\n        'https://dhgate.com/product/test',\n        'https://www.dhgate.co.uk/store/67890'\n      ];\n      \n      validUrls.forEach(url => {\n        const result = SecurityUtils.validateShopUrl(url);\n        expect(result.isValid).toBe(true);\n      });\n    });\n    \n    test('should reject non-DHgate URLs', () => {\n      const invalidUrls = [\n        'https://www.aliexpress.com/store/12345',\n        'https://www.amazon.com/product',\n        'https://malicious-site.com',\n        'not-a-url'\n      ];\n      \n      invalidUrls.forEach(url => {\n        const result = SecurityUtils.validateShopUrl(url);\n        expect(result.isValid).toBe(false);\n      });\n    });\n    \n    test('should handle empty or invalid input', () => {\n      const invalidInputs = [null, undefined, '', 123];\n      \n      invalidInputs.forEach(input => {\n        const result = SecurityUtils.validateShopUrl(input);\n        expect(result.isValid).toBe(false);\n        expect(result.error).toBe('URL is required');\n      });\n    });\n  });\n  \n  describe('sanitizeHtml', () => {\n    test('should sanitize HTML entities', () => {\n      const input = '<script>alert(\"XSS\")</script>&\"unsafe\"';\n      const expected = '&lt;script&gt;alert(&quot;XSS&quot;)&lt;&#x2F;script&gt;&amp;&quot;unsafe&quot;';\n      const result = SecurityUtils.sanitizeHtml(input);\n      expect(result).toBe(expected);\n    });\n    \n    test('should handle empty input', () => {\n      expect(SecurityUtils.sanitizeHtml('')).toBe('');\n      expect(SecurityUtils.sanitizeHtml(null)).toBe('');\n      expect(SecurityUtils.sanitizeHtml(undefined)).toBe('');\n    });\n    \n    test('should sanitize all dangerous characters', () => {\n      const input = '&<>\"\\'/'\n      const expected = '&amp;&lt;&gt;&quot;&#x27;&#x2F;';\n      const result = SecurityUtils.sanitizeHtml(input);\n      expect(result).toBe(expected);\n    });\n  });\n  \n  describe('generateCSRFToken', () => {\n    test('should generate a 64-character hex string', () => {\n      const token = SecurityUtils.generateCSRFToken();\n      expect(typeof token).toBe('string');\n      expect(token).toHaveLength(64);\n      expect(token).toMatch(/^[0-9a-f]{64}$/);\n    });\n    \n    test('should generate unique tokens', () => {\n      const token1 = SecurityUtils.generateCSRFToken();\n      const token2 = SecurityUtils.generateCSRFToken();\n      expect(token1).not.toBe(token2);\n    });\n  });\n});\n\ndescribe('ErrorHandler', () => {\n  describe('withRetry', () => {\n    test('should succeed on first attempt', async () => {\n      const mockFn = jest.fn().mockResolvedValue('success');\n      const result = await ErrorHandler.withRetry(mockFn);\n      \n      expect(result).toBe('success');\n      expect(mockFn).toHaveBeenCalledTimes(1);\n    });\n    \n    test('should retry on failure and eventually succeed', async () => {\n      const mockFn = jest.fn()\n        .mockRejectedValueOnce(new Error('Attempt 1 failed'))\n        .mockRejectedValueOnce(new Error('Attempt 2 failed'))\n        .mockResolvedValue('success');\n      \n      const result = await ErrorHandler.withRetry(mockFn);\n      \n      expect(result).toBe('success');\n      expect(mockFn).toHaveBeenCalledTimes(3);\n    });\n    \n    test('should throw after max retries', async () => {\n      const mockFn = jest.fn().mockRejectedValue(new Error('Always fails'));\n      \n      await expect(ErrorHandler.withRetry(mockFn, 2)).rejects.toThrow('Always fails');\n      expect(mockFn).toHaveBeenCalledTimes(2);\n    });\n  });\n  \n  describe('safeExecute', () => {\n    test('should return result on success', async () => {\n      const mockFn = jest.fn().mockResolvedValue('success');\n      const result = await ErrorHandler.safeExecute(mockFn, 'test operation');\n      \n      expect(result).toBe('success');\n    });\n    \n    test('should return fallback value on error', async () => {\n      const mockFn = jest.fn().mockRejectedValue(new Error('Failed'));\n      const result = await ErrorHandler.safeExecute(mockFn, 'test operation', 'fallback');\n      \n      expect(result).toBe('fallback');\n    });\n    \n    test('should return null by default on error', async () => {\n      const mockFn = jest.fn().mockRejectedValue(new Error('Failed'));\n      const result = await ErrorHandler.safeExecute(mockFn, 'test operation');\n      \n      expect(result).toBe(null);\n    });\n  });\n});\n\ndescribe('AnalyticsService', () => {\n  beforeEach(() => {\n    gtag.mockClear();\n    sessionStorage.getItem.mockClear();\n    sessionStorage.setItem.mockClear();\n  });\n  \n  describe('trackConversion', () => {\n    test('should call gtag with correct parameters', () => {\n      sessionStorage.getItem.mockReturnValue('existing-session-id');\n      \n      AnalyticsService.trackConversion('test_event', {\n        custom_param: 'value'\n      });\n      \n      expect(gtag).toHaveBeenCalledWith('event', 'test_event', {\n        custom_param: 'value',\n        event_category: 'conversion',\n        event_timestamp: expect.any(String),\n        session_id: 'existing-session-id'\n      });\n    });\n    \n    test('should not call gtag if gtag is not available', () => {\n      const originalGtag = global.gtag;\n      global.gtag = undefined;\n      \n      AnalyticsService.trackConversion('test_event');\n      \n      expect(gtag).not.toHaveBeenCalled();\n      \n      global.gtag = originalGtag;\n    });\n  });\n  \n  describe('getSessionId', () => {\n    test('should return existing session ID', () => {\n      sessionStorage.getItem.mockReturnValue('existing-session-id');\n      \n      const sessionId = AnalyticsService.getSessionId();\n      \n      expect(sessionId).toBe('existing-session-id');\n      expect(sessionStorage.setItem).not.toHaveBeenCalled();\n    });\n    \n    test('should create new session ID if none exists', () => {\n      sessionStorage.getItem.mockReturnValue(null);\n      \n      const sessionId = AnalyticsService.getSessionId();\n      \n      expect(sessionId).toMatch(/^sess_\\d+_[a-z0-9]{9}$/);\n      expect(sessionStorage.setItem).toHaveBeenCalledWith('dhgate_session_id', sessionId);\n    });\n  });\n});\n\n// Integration tests\ndescribe('Integration Tests', () => {\n  test('should handle complete email validation and sanitization flow', () => {\n    const userInput = '  TEST@example.com  ';\n    const emailResult = SecurityUtils.validateEmail(userInput);\n    \n    expect(emailResult.isValid).toBe(true);\n    \n    const sanitizedHtml = SecurityUtils.sanitizeHtml(`<p>Welcome ${emailResult.sanitized}!</p>`);\n    expect(sanitizedHtml).toBe('&lt;p&gt;Welcome test@example.com!&lt;&#x2F;p&gt;');\n  });\n  \n  test('should handle URL validation with error handling', async () => {\n    const testUrl = 'https://www.dhgate.com/store/12345';\n    \n    const result = await ErrorHandler.safeExecute(\n      () => SecurityUtils.validateShopUrl(testUrl),\n      'URL validation',\n      { isValid: false, error: 'Fallback error' }\n    );\n    \n    expect(result.isValid).toBe(true);\n    expect(result.sanitized).toBe(testUrl);\n  });\n});"